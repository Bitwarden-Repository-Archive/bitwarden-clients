diff a/apps/web/src/app/tools/reports/pages/weak-passwords-report.component.ts b/apps/web/src/app/tools/reports/pages/weak-passwords-report.component.ts	(rejected hunks)
@@ -13,6 +13,7 @@ import { BadgeVariant } from "@bitwarden/components";
 import { PasswordRepromptService } from "@bitwarden/vault";
 
 import { CipherReportComponent } from "./cipher-report.component";
+import { AuditService } from "@bitwarden/common/abstractions/audit.service";
 
 @Component({
   selector: "app-weak-passwords-report",
@@ -25,10 +26,17 @@ export class WeakPasswordsReportComponent extends CipherReportComponent implemen
   private passwordStrengthCache = new Map<string, number>();
   weakPasswordCiphers: CipherView[] = [];
 
+  reusedPasswordCiphers: CipherView[] = [];
+  passwordUseMap: Map<string, number>;
+
+  exposedPasswordCiphers: CipherView[] = [];
+  exposedPasswordMap = new Map<string, number>();
+
   constructor(
     protected cipherService: CipherService,
     protected passwordStrengthService: PasswordStrengthServiceAbstraction,
     protected organizationService: OrganizationService,
+    protected auditService: AuditService,
     modalService: ModalService,
     passwordRepromptService: PasswordRepromptService,
     i18nService: I18nService,
@@ -50,10 +58,78 @@ export class WeakPasswordsReportComponent extends CipherReportComponent implemen
 
   async setCiphers() {
     const allCiphers: any = await this.getAllCiphers();
+    this.setWeakPasswordMap(allCiphers);
+    this.setReusedPasswordMap(allCiphers);
+    await this.setExposedPasswordMap(allCiphers);    
+
+    
+
+  }
+
+  protected setWeakPasswordMap(ciphers: any[]) {
     this.passwordStrengthCache = new Map<string, number>();
     this.weakPasswordCiphers = [];
     this.filterStatus = [0];
-    this.findWeakPasswords(allCiphers);
+    this.findWeakPasswords(ciphers);
+  }
+
+  protected async setExposedPasswordMap(ciphers: any[]) {
+    const promises: Promise<void>[] = [];
+    this.filterStatus = [0];
+
+    ciphers.forEach((ciph: any) => {
+      const { type, login, isDeleted, edit, viewPassword, id } = ciph;
+      if (
+        type !== CipherType.Login ||
+        login.password == null ||
+        login.password === "" ||
+        isDeleted ||
+        (!this.organization && !edit) ||
+        !viewPassword
+      ) {
+        return;
+      }
+
+      const promise = this.auditService.passwordLeaked(login.password).then((exposedCount) => {
+        if (exposedCount > 0) {
+          this.exposedPasswordCiphers.push(ciph);
+          this.exposedPasswordMap.set(id, exposedCount);
+        }
+      });
+      promises.push(promise);
+    });
+    await Promise.all(promises);
+  }
+
+  protected setReusedPasswordMap(ciphers: any[]): void {
+    const ciphersWithPasswords: CipherView[] = [];
+    this.passwordUseMap = new Map<string, number>();
+    this.filterStatus = [0];
+
+    ciphers.forEach((ciph) => {
+      const { type, login, isDeleted, edit, viewPassword } = ciph;
+      if (
+        type !== CipherType.Login ||
+        login.password == null ||
+        login.password === "" ||
+        isDeleted ||
+        (!this.organization && !edit) ||
+        !viewPassword
+      ) {
+        return;
+      }
+
+      ciphersWithPasswords.push(ciph);
+      if (this.passwordUseMap.has(login.password)) {
+        this.passwordUseMap.set(login.password, this.passwordUseMap.get(login.password) + 1);
+      } else {
+        this.passwordUseMap.set(login.password, 1);
+      }
+    });
+    this.reusedPasswordCiphers = ciphersWithPasswords.filter(
+      (c) =>
+        this.passwordUseMap.has(c.login.password) && this.passwordUseMap.get(c.login.password) > 1,
+    );
   }
 
   protected findWeakPasswords(ciphers: any[]): void {
@@ -114,8 +190,6 @@ export class WeakPasswordsReportComponent extends CipherReportComponent implemen
         this.passwordStrengthCache.get(this.getCacheKey(b))
       );
     });
-
-    this.filterCiphersByOrg(this.weakPasswordCiphers);
   }
 
   protected canManageCipher(c: CipherView): boolean {
